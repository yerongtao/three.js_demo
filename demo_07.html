<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<title>室内效果</title>
	<style>
		body {
			background-color: rgb(200,200,200);
			margin: 0px;
			overflow: hidden;
		}
		a {
			color: #ffffff;
		}
	</style>
</head>
<body>

<div id="container" style="width: 800px;height: 600px">

</div>

<script src="js/three.js"></script>
<script src="js/controls/FirstPersonControls.js"></script>

<script>

    var camera, scene, renderer;

    var moveForward = false;
    var moveBackward = false;
    var moveLeft = false;
    var moveRight = false;
    var activeLook = true;

    var texture_placeholder,
        isUserInteracting = false,//用户交互，初始为false
        onMouseDownMouseX = 0,
		onMouseDownMouseY = 0,

        lon = 90, onMouseDownLon = 0,
        lat = 0, onMouseDownLat = 0,
        phi = 0,
        theta = 0,
        target = new THREE.Vector3();

    init();
    animate();

    function init() {

        var container, mesh;

        container = document.getElementById( 'container' );
        //照相机
        camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 1100 );
        //场景
        scene = new THREE.Scene();


        var materials = [
            loadTexture( 'img/room/13.jpg' ),
            loadTexture( 'img/room/11.jpg' ),
            loadTexture( 'img/room/16.jpg' ),
            loadTexture( 'img/room/15.jpg' ),
            loadTexture( 'img/room/12.jpg' ),
            loadTexture( 'img/room/14.jpg' )
        ];
        //实体
        //BoxGeometry用来在三维空间内创建一个立方体盒子对象.
        mesh = new THREE.Mesh( new THREE.BoxGeometry( 300, 300, 300, 1, 1, 1 ), materials);
        mesh.scale.x =  -1;
        scene.add( mesh );
        //渲染器
        renderer = new THREE.WebGLRenderer();
        renderer.setPixelRatio( window.devicePixelRatio );
        //renderer.setSize( window.innerWidth, window.innerHeight );
        renderer.setSize( 1500, 800 );
        container.appendChild( renderer.domElement );


        //addEventListener()用于向指定元素添加事件句柄
        document.addEventListener( 'mousedown', onMouseDown, false );
        document.addEventListener( 'mousemove', onDocumentMouseMove, false );
        document.addEventListener( 'mouseup', onMouseUp, false );
        //鼠标滚轮控制缩放
        document.addEventListener( 'wheel', onDocumentMouseWheel, false );

        document.addEventListener( 'touchstart', onDocumentTouchStart, false );
        document.addEventListener( 'touchmove', onDocumentTouchMove, false );

        //
        window.addEventListener( 'resize', onWindowResize, false );

    }

    function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

    }

    function loadTexture( path ) {

        var texture = new THREE.Texture( texture_placeholder );
        var material = new THREE.MeshBasicMaterial( { map: texture, overdraw: 0.5 } );

        var image = new Image();
        image.onload = function () {

            texture.image = this;
            texture.needsUpdate = true;

        };
        image.src = path;

        return material;

    }

    //鼠标点击时触发的函数
    function onDocumentMouseDown( event ) {

        event.preventDefault();

        isUserInteracting = true;

        //
        onPointerDownPointerX = event.clientX;//触摸目标在视口中的x坐标
        onPointerDownPointerY = event.clientY;//触摸目标在视口中的y坐标

        onPointerDownLon = lon;
        onPointerDownLat = lat;

    }

    //鼠标移开时触发的函数
    function onDocumentMouseMove( event ) {

        if ( isUserInteracting === true ) {

            lon = ( onPointerDownPointerX - event.clientX ) * 0.1 + onPointerDownLon;
            lat = ( event.clientY - onPointerDownPointerY ) * 0.1 + onPointerDownLat;

        }

    }

    //鼠标点击弹起后时触发的函数
    function onDocumentMouseUp( event ) {

        isUserInteracting = false;

    }

    //鼠标滚轮滚动时，控制缩放
    function onDocumentMouseWheel( event ) {
        //控制缩放其实是改变照相机位置，照相机离得远了，物体就变小了
        camera.fov += event.deltaY * 0.05;
        camera.updateProjectionMatrix();

    }


    function onDocumentTouchStart( event ) {

        if ( event.touches.length == 1 ) {

            event.preventDefault();

            onPointerDownPointerX = event.touches[ 0 ].pageX;
            onPointerDownPointerY = event.touches[ 0 ].pageY;

            onPointerDownLon = lon;
            onPointerDownLat = lat;

        }

    }

    function onDocumentTouchMove( event ) {

        if ( event.touches.length == 1 ) {

            event.preventDefault();

            lon = ( onPointerDownPointerX - event.touches[0].pageX ) * 0.1 + onPointerDownLon;
            lat = ( event.touches[0].pageY - onPointerDownPointerY ) * 0.1 + onPointerDownLat;

        }

    }

    //鼠标点击执行函数
    function onMouseDown ( event ) {

        event.preventDefault();//通知浏览器不要执行与事件关联的默认动作
        event.stopPropagation();//不再派发事件

        if ( activeLook ) {
            switch ( event.button ) {//event.button返回当前事件点击的鼠标按键
                case 0: //鼠标左键，前进
                    moveForward = true; break;
                case 2: //鼠标右键，后退
                    moveBackward = true; break;
            }
        }
    }

    //鼠标点击后弹起执行函数
    function onMouseUp ( event ) {

        event.preventDefault();//通知浏览器不要执行与事件关联的默认动作
        event.stopPropagation();//不再派发事件

        if ( activeLook ) {

            switch ( event.button ) {

                case 0: //鼠标左键，停止前进
                    moveForward = false; break;
                case 2: //鼠标右键，停止后退
                    moveBackward = false; break;
            }
        }

    }


    function animate() {
        requestAnimationFrame( animate );//递归调用
        update();

    }

    function update() {

        if ( moveForward ) {
            scene.translateZ( - 1 );//定义3D转换
		}


        //当用户无交互时，设置角度自增变化
        if ( isUserInteracting === false ) {
            //lon初始值为90，每次递增0.1，角度值变换
            lon += 0.1;
        }

        //角度值计算
        lat = Math.max( - 85, Math.min( 85, lat ) );
        phi = THREE.Math.degToRad( 90 - lat );
        theta = THREE.Math.degToRad( lon );

        //设置移动算法
        target.x = 500 * Math.sin( phi ) * Math.cos( theta );
        target.y = 500 * Math.cos( phi );
        target.z = 500 * Math.sin( phi ) * Math.sin( theta );

        //设置照相机看向target方向
        camera.lookAt( target );
        //渲染
        renderer.render( scene, camera );

    }

</script>
</body>
</html>
